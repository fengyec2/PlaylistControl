## éœ€è¦çš„æ–‡ä»¶

1. **`utils/system_utils.py`** - äº†è§£ç³»ç»Ÿå·¥å…·å‡½æ•°çš„å®ç°æ–¹å¼

```python
# å…¨å±€å˜é‡æ§åˆ¶è°ƒè¯•è¾“å‡º
_verbose_mode = False

def set_verbose_mode(verbose: bool):
    """è®¾ç½®è¯¦ç»†è¾“å‡ºæ¨¡å¼"""
    global _verbose_mode
    _verbose_mode = verbose

def debug_print(message):
    """åªåœ¨ verbose æ¨¡å¼ä¸‹æ‰“å°è°ƒè¯•ä¿¡æ¯"""
    if _verbose_mode:
        safe_print(message)

def get_executable_dir():
    """è·å–å¯æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•"""
    if getattr(sys, 'frozen', False):
        # PyInstaller æ‰“åŒ…åçš„å¯æ‰§è¡Œæ–‡ä»¶
        exe_dir = os.path.dirname(sys.executable)
        debug_print(f"ğŸ”§ è°ƒè¯•ï¼šæ‰“åŒ…æ¨¡å¼ï¼Œexeç›®å½•: {exe_dir}")
        return exe_dir
    else:
        # æ™®é€š Python è„šæœ¬
        script_dir = os.path.dirname(os.path.abspath(__file__))
        debug_print(f"ğŸ”§ è°ƒè¯•ï¼šè„šæœ¬æ¨¡å¼ï¼Œè„šæœ¬ç›®å½•: {script_dir}")
        return script_dir

def get_config_file_path():
    """è·å–é…ç½®æ–‡ä»¶è·¯å¾„"""
    config_path = os.path.join(get_executable_dir(), 'config.json')
    debug_print(f"ğŸ”§ è°ƒè¯•ï¼šé…ç½®æ–‡ä»¶è·¯å¾„: {config_path}")
    return config_path

def get_database_path():
    """è·å–æ•°æ®åº“æ–‡ä»¶è·¯å¾„"""
    db_path = os.path.join(get_executable_dir(), 'media_history.db')
    debug_print(f"ğŸ”§ è°ƒè¯•ï¼šæ•°æ®åº“è·¯å¾„: {db_path}")
    return db_path

def get_log_file_path():
    """è·å–æ—¥å¿—æ–‡ä»¶è·¯å¾„"""
    log_path = os.path.join(get_executable_dir(), 'media_tracker.log')
    debug_print(f"ğŸ”§ è°ƒè¯•ï¼šæ—¥å¿—æ–‡ä»¶è·¯å¾„: {log_path}")
    return log_path

def get_pid_file_path(pid_file: str = None) -> str:
    """è·å– PID æ–‡ä»¶çš„å®Œæ•´è·¯å¾„"""
    if pid_file is None:
        pid_file = "media_tracker.pid"
    
    # å¦‚æœå·²ç»æ˜¯ç»å¯¹è·¯å¾„ï¼Œç›´æ¥è¿”å›
    if os.path.isabs(pid_file):
        pid_path = pid_file
    else:
        # å¦åˆ™æ”¾åœ¨å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•ä¸‹
        pid_path = os.path.join(get_executable_dir(), pid_file)
    
    debug_print(f"ğŸ”§ è°ƒè¯•ï¼šPIDæ–‡ä»¶è·¯å¾„: {pid_path}")
    return pid_path

def check_and_install_dependencies() -> bool:
    """æ£€æŸ¥å¹¶å®‰è£…ä¾èµ–"""
    try:
        import winsdk.windows.media.control as wmc
        return True
    except ImportError:
        safe_print("âŒ ç¼ºå°‘å¿…è¦çš„ winsdk åº“")
        safe_print("ğŸ”§ æ­£åœ¨å°è¯•è‡ªåŠ¨å®‰è£…...")
        
        try:
            import subprocess
            import sys
            subprocess.check_call([sys.executable, "-m", "pip", "install", "winsdk"])
            safe_print("âœ… winsdk å®‰è£…æˆåŠŸ!")
            safe_print("ğŸ”„ è¯·é‡æ–°è¿è¡Œç¨‹åº")
            return False
        except Exception as e:
            safe_print(f"âŒ è‡ªåŠ¨å®‰è£…å¤±è´¥: {e}")
            safe_print("ğŸ› ï¸ è¯·æ‰‹åŠ¨æ‰§è¡Œ: pip install winsdk")
            return False

def setup_signal_handlers(monitor):
    """è®¾ç½®ä¿¡å·å¤„ç†å™¨ï¼Œç”¨äºä¼˜é›…é€€å‡º"""
    def signal_handler(signum, frame):
        safe_print(f"\næ¥æ”¶åˆ°é€€å‡ºä¿¡å· ({signum})ï¼Œæ­£åœ¨ä¼˜é›…é€€å‡º...")
        # è®¾ç½®åœæ­¢æ ‡å¿—ï¼Œè€Œä¸æ˜¯ç›´æ¥é€€å‡º
        monitor.set_stop_flag()
        # ä¸è¦åœ¨è¿™é‡Œè°ƒç”¨ sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

def is_process_running(pid: int) -> bool:
    """æ£€æŸ¥è¿›ç¨‹æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
    try:
        if sys.platform == "win32":
            result = subprocess.run(
                ['tasklist', '/FI', f'PID eq {pid}'],
                capture_output=True,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            return str(pid) in result.stdout
        else:
            # Unix-likeç³»ç»Ÿ
            os.kill(pid, 0)  # å‘é€ä¿¡å·0æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
            return True
    except (OSError, subprocess.SubprocessError):
        return False

def terminate_process(pid: int) -> bool:
    """ç»ˆæ­¢æŒ‡å®šPIDçš„è¿›ç¨‹"""
    try:
        if sys.platform == "win32":
            # é¦–å…ˆå°è¯•æ­£å¸¸ç»ˆæ­¢
            result = subprocess.run(
                ['taskkill', '/PID', str(pid)],
                capture_output=True,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            if result.returncode == 0:
                return True
            
            # å¦‚æœæ­£å¸¸ç»ˆæ­¢å¤±è´¥ï¼Œå°è¯•å¼ºåˆ¶ç»ˆæ­¢
            result = subprocess.run(
                ['taskkill', '/PID', str(pid), '/F'],
                capture_output=True,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            return result.returncode == 0
        else:
            # Unix-likeç³»ç»Ÿ
            os.kill(pid, signal.SIGTERM)
            # ç­‰å¾…ä¸€ä¸‹ï¼Œå¦‚æœè¿›ç¨‹è¿˜åœ¨è¿è¡Œå°±å¼ºåˆ¶æ€æ­»
            time.sleep(2)
            try:
                os.kill(pid, 0)  # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨
                os.kill(pid, signal.SIGKILL)  # å¼ºåˆ¶æ€æ­»
            except OSError:
                pass  # è¿›ç¨‹å·²ç»åœæ­¢
            return True
    except Exception as e:
        safe_print(f"ç»ˆæ­¢è¿›ç¨‹å¤±è´¥: {e}")
        return False
```

2. **`core/media_monitor.py`** - äº†è§£ç°æœ‰çš„åª’ä½“ç›‘æ§å®ç°ï¼Œå¯èƒ½åŒ…å«è¿›ç¨‹æ£€æµ‹ç­‰åŠŸèƒ½

```python
class MediaMonitor:
    def __init__(self):
        self.current_session = None
        self.running = False
        self._stop_flag = False
        self._monitoring_task = None
        self.last_complete_info = {}  # ç¼“å­˜ä¸Šä¸€æ¬¡å®Œæ•´çš„ä¿¡æ¯
        self.pending_info_cache = {}  # ç¼“å­˜å¾…éªŒè¯çš„ä¿¡æ¯
        
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.running = False
        self._stop_flag = True
        # å¦‚æœæœ‰æ­£åœ¨è¿è¡Œçš„ç›‘æ§ä»»åŠ¡ï¼Œå–æ¶ˆå®ƒ
        if self._monitoring_task and not self._monitoring_task.done():
            self._monitoring_task.cancel()
    
    def set_stop_flag(self):
        """è®¾ç½®åœæ­¢æ ‡å¿—"""
        self._stop_flag = True
        self.running = False
    
    def _is_duration_valid(self, duration: int) -> bool:
        """æ£€æŸ¥æ—¶é•¿æ˜¯å¦æœ‰æ•ˆ"""
        return duration is not None and duration > 0
    
    def _is_info_complete(self, media_info: Dict[str, Any]) -> bool:
        """æ£€æŸ¥åª’ä½“ä¿¡æ¯æ˜¯å¦å®Œæ•´"""
        if not media_info.get('title'):
            return False
        
        # å¯¹äºæ­£åœ¨æ’­æ”¾çš„æ­Œæ›²ï¼Œæ—¶é•¿åº”è¯¥æ˜¯æœ‰æ•ˆçš„
        if media_info.get('status') == 'Playing':
            return self._is_duration_valid(media_info.get('duration', 0))
        
        return True
    
    def _calculate_info_completeness_score(self, media_info: Dict[str, Any]) -> int:
        """è®¡ç®—ä¿¡æ¯å®Œæ•´åº¦åˆ†æ•°"""
        score = 0
        important_fields = {
            'title': 3,      # æ­Œåæœ€é‡è¦
            'artist': 2,     # è‰ºæœ¯å®¶é‡è¦
            'duration': 2,   # æ—¶é•¿é‡è¦
            'album': 1,      # ä¸“è¾‘ä¸€èˆ¬é‡è¦
            'status': 1      # çŠ¶æ€ä¸€èˆ¬é‡è¦
        }
        
        for field, weight in important_fields.items():
            value = media_info.get(field)
            if value and str(value) not in ['', 'Unknown', '0']:
                if field == 'duration' and self._is_duration_valid(value):
                    score += weight
                elif field != 'duration':
                    score += weight
        
        return score
    
    def _merge_media_info(self, cached_info: Dict[str, Any], new_info: Dict[str, Any]) -> Dict[str, Any]:
        """æ™ºèƒ½åˆå¹¶åª’ä½“ä¿¡æ¯ï¼Œä¼˜å…ˆä½¿ç”¨æ›´å®Œæ•´çš„æ•°æ®"""
        if not cached_info:
            return new_info
        
        merged = cached_info.copy()
        
        # ä¼˜å…ˆä½¿ç”¨æ–°çš„éç©ºå€¼
        for key, value in new_info.items():
            if value and str(value) not in ['', 'Unknown', '0']:
                # å¯¹äºæ—¶é•¿å­—æ®µï¼Œç¡®ä¿æ–°å€¼æ˜¯æœ‰æ•ˆçš„
                if key == 'duration':
                    if self._is_duration_valid(value):
                        merged[key] = value
                else:
                    merged[key] = value
        
        return merged
    
    def _get_track_identifier(self, media_info: Dict[str, Any]) -> str:
        """ç”Ÿæˆæ­Œæ›²çš„å”¯ä¸€æ ‡è¯†ç¬¦"""
        return f"{media_info.get('title', '')}_{media_info.get('artist', '')}_{media_info.get('app_name', '')}"

    async def get_media_info(self) -> Dict[str, Any]:
        """è·å–å½“å‰æ’­æ”¾çš„åª’ä½“ä¿¡æ¯ï¼Œå¸¦é‡è¯•å’ŒéªŒè¯æœºåˆ¶"""
        try:
            # æ£€æŸ¥åœæ­¢æ ‡å¿—
            if self._stop_flag:
                return {}
                
            # è·å–åŸºç¡€ä¿¡æ¯
            raw_info = await self._get_raw_media_info()
            
            if not raw_info or not raw_info.get('title'):
                return {}
            
            track_id = self._get_track_identifier(raw_info)
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°æ­Œæ›²
            is_new_track = track_id not in self.last_complete_info
            
            # å¦‚æœæ˜¯æ–°æ­Œæ›²ä¸”ä¿¡æ¯ä¸å®Œæ•´ï¼Œå°è¯•è·å–å®Œæ•´ä¿¡æ¯
            if is_new_track and not self._is_info_complete(raw_info):
                complete_info = await self._get_complete_media_info(raw_info)
                if complete_info:
                    self.last_complete_info[track_id] = complete_info
                    return complete_info
            
            # å¦‚æœæ˜¯å·²çŸ¥æ­Œæ›²ï¼Œåˆå¹¶ä¿¡æ¯
            if track_id in self.last_complete_info:
                merged_info = self._merge_media_info(self.last_complete_info[track_id], raw_info)
                self.last_complete_info[track_id] = merged_info
                return merged_info
            
            # å­˜å‚¨å®Œæ•´ä¿¡æ¯
            if self._is_info_complete(raw_info):
                self.last_complete_info[track_id] = raw_info
            
            return raw_info
            
        except Exception as e:
            logger.error(f"è·å–åª’ä½“ä¿¡æ¯æ—¶å‡ºé”™: {e}")
            return {}
    
    async def _get_complete_media_info(self, initial_info: Dict[str, Any], max_wait: float = 5.0) -> Dict[str, Any]:
        """ç­‰å¾…è·å–å®Œæ•´çš„åª’ä½“ä¿¡æ¯ï¼Œç‰¹åˆ«æ˜¯æ—¶é•¿ä¿¡æ¯"""
        start_time = time.time()
        best_info = initial_info
        best_score = self._calculate_info_completeness_score(initial_info)
        
        logger.debug(f"ç­‰å¾…å®Œæ•´ä¿¡æ¯: {initial_info.get('title', 'Unknown')} (åˆå§‹åˆ†æ•°: {best_score})")
        
        retry_intervals = [0.5, 1.0, 1.5, 2.0]  # æ¸è¿›å¼é‡è¯•é—´éš”
        
        for retry_interval in retry_intervals:
            if time.time() - start_time >= max_wait or self._stop_flag:
                break
                
            try:
                await asyncio.sleep(retry_interval)
            except asyncio.CancelledError:
                logger.debug("ç­‰å¾…åª’ä½“ä¿¡æ¯æ—¶è¢«å–æ¶ˆ")
                break
            
            # å†æ¬¡æ£€æŸ¥åœæ­¢æ ‡å¿—
            if self._stop_flag:
                break
            
            try:
                current_info = await self._get_raw_media_info()
                
                if not current_info or not current_info.get('title'):
                    continue
                
                # ç¡®ä¿è¿˜æ˜¯åŒä¸€é¦–æ­Œ
                if (current_info.get('title') != initial_info.get('title') or 
                    current_info.get('artist') != initial_info.get('artist')):
                    logger.debug("æ­Œæ›²å·²åˆ‡æ¢ï¼Œåœæ­¢ç­‰å¾…")
                    break
                
                current_score = self._calculate_info_completeness_score(current_info)
                
                # å¦‚æœæ‰¾åˆ°æ›´å®Œæ•´çš„ä¿¡æ¯
                if current_score > best_score:
                    best_info = current_info
                    best_score = current_score
                    logger.debug(f"æ‰¾åˆ°æ›´å®Œæ•´çš„ä¿¡æ¯ (åˆ†æ•°: {current_score})")
                    
                    # å¦‚æœä¿¡æ¯å·²ç»è¶³å¤Ÿå®Œæ•´ï¼Œæå‰é€€å‡º
                    if self._is_info_complete(current_info):
                        logger.debug("ä¿¡æ¯å·²å®Œæ•´ï¼Œæå‰ç»“æŸç­‰å¾…")
                        break
                        
            except Exception as e:
                logger.debug(f"é‡è¯•è·å–ä¿¡æ¯æ—¶å‡ºé”™: {e}")
                continue
        
        elapsed = time.time() - start_time
        logger.debug(f"ç­‰å¾…å®Œæˆï¼Œè€—æ—¶: {elapsed:.1f}sï¼Œæœ€ç»ˆåˆ†æ•°: {best_score}")
        
        return best_info

    async def _get_raw_media_info(self) -> Dict[str, Any]:
        """è·å–åŸå§‹åª’ä½“ä¿¡æ¯ï¼ˆå•æ¬¡è°ƒç”¨ï¼‰"""
        try:
            # æ£€æŸ¥åœæ­¢æ ‡å¿—
            if self._stop_flag:
                return {}
                
            sessions_manager = await wmc.GlobalSystemMediaTransportControlsSessionManager.request_async()
            current_session = sessions_manager.get_current_session()
            
            if current_session is None:
                return {}
                
            # è·å–åª’ä½“å±æ€§
            try:
                media_properties = await current_session.try_get_media_properties_async()
            except Exception as e:
                logger.debug(f"è·å–åª’ä½“å±æ€§å¤±è´¥: {e}")
                media_properties = None
                
            # è·å–æ’­æ”¾ä¿¡æ¯
            try:
                playback_info = current_session.get_playback_info()
                timeline_info = current_session.get_timeline_properties()
            except Exception as e:
                logger.debug(f"è·å–æ’­æ”¾ä¿¡æ¯å¤±è´¥: {e}")
                playback_info = None
                timeline_info = None
                
            media_info = {}
            
            if media_properties:
                media_info.update({
                    'title': media_properties.title or '',
                    'artist': media_properties.artist or '',
                    'album': media_properties.album_title or '',
                    'album_artist': media_properties.album_artist or '',
                    'track_number': media_properties.track_number or 0,
                    'genre': getattr(media_properties, 'genres', [None])[0] if hasattr(media_properties, 'genres') and media_properties.genres else '',
                })
                
                # å°è¯•è·å–å¹´ä»½
                try:
                    if hasattr(media_properties, 'year') and media_properties.year:
                        media_info['year'] = media_properties.year
                except:
                    media_info['year'] = 0
                
            if playback_info:
                status_map = {
                    0: 'Closed',
                    1: 'Opened', 
                    2: 'Changing',
                    3: 'Stopped',
                    4: 'Playing',
                    5: 'Paused'
                }
                media_info['status'] = status_map.get(playback_info.playback_status, 'Unknown')
                
            if timeline_info:
                try:
                    media_info.update({
                        'duration': int(timeline_info.end_time.total_seconds()) if timeline_info.end_time else 0,
                        'position': int(timeline_info.position.total_seconds()) if timeline_info.position else 0,
                    })
                except:
                    media_info.update({
                        'duration': 0,
                        'position': 0,
                    })
                
            # è·å–åº”ç”¨ä¿¡æ¯
            try:
                app_id = current_session.source_app_user_model_id or 'Unknown'
                media_info['app_id'] = app_id
                media_info['app_name'] = config.get_app_name(app_id)
                
                # æ£€æŸ¥æ˜¯å¦å¿½ç•¥æ­¤åº”ç”¨
                if config.is_app_ignored(app_id):
                    return {}
                    
            except Exception as e:
                logger.debug(f"è·å–åº”ç”¨ä¿¡æ¯å¤±è´¥: {e}")
                media_info['app_name'] = 'Unknown'
                media_info['app_id'] = 'Unknown'
                
            return media_info
            
        except Exception as e:
            logger.error(f"è·å–åŸå§‹åª’ä½“ä¿¡æ¯æ—¶å‡ºé”™: {e}")
            return {}
            
    def _format_media_output(self, media_info: Dict[str, Any], current_time: datetime, silent_mode: bool = False) -> None:
        """æ ¼å¼åŒ–åª’ä½“è¾“å‡º"""
        if silent_mode:
            return
            
        use_emoji = config.should_use_emoji()
        
        safe_print(f"[{current_time.strftime('%H:%M:%S')}] æ­£åœ¨æ’­æ”¾:")
        
        title_prefix = "ğŸµ " if use_emoji else ""
        safe_print(f"  {title_prefix}æ­Œæ›²: {media_info.get('title', 'Unknown')}")
        
        if media_info.get('artist'):
            artist_prefix = "ğŸ¤ " if use_emoji else ""
            safe_print(f"  {artist_prefix}è‰ºæœ¯å®¶: {media_info.get('artist')}")
            
        if media_info.get('album'):
            album_prefix = "ğŸ’¿ " if use_emoji else ""
            safe_print(f"  {album_prefix}ä¸“è¾‘: {media_info.get('album')}")
            
        if media_info.get('album_artist') and media_info.get('album_artist') != media_info.get('artist'):
            group_prefix = "ğŸ‘¥ " if use_emoji else ""
            safe_print(f"  {group_prefix}ä¸“è¾‘è‰ºæœ¯å®¶: {media_info.get('album_artist')}")
            
        if config.get("display.show_track_number", True) and media_info.get('track_number'):
            track_prefix = "ğŸ”¢ " if use_emoji else ""
            safe_print(f"  {track_prefix}æ›²ç›®å·: {media_info.get('track_number')}")
            
        if config.get("display.show_genre", True) and media_info.get('genre'):
            genre_prefix = "ğŸ­ " if use_emoji else ""
            safe_print(f"  {genre_prefix}æµæ´¾: {media_info.get('genre')}")
            
        if config.get("display.show_year", True) and media_info.get('year'):
            year_prefix = "ğŸ“… " if use_emoji else ""
            safe_print(f"  {year_prefix}å¹´ä»½: {media_info.get('year')}")
            
        app_prefix = "ğŸ“± " if use_emoji else ""
        safe_print(f"  {app_prefix}åº”ç”¨: {media_info.get('app_name', 'Unknown')}")
        
        status_prefix = "âš¡ " if use_emoji else ""
        safe_print(f"  {status_prefix}çŠ¶æ€: {media_info.get('status', 'Unknown')}")
        
        if config.get("display.show_progress", True) and media_info.get('duration'):
            duration_str = f"{media_info['duration']//60}:{media_info['duration']%60:02d}"
            position_str = f"{media_info.get('position', 0)//60}:{media_info.get('position', 0)%60:02d}"
            progress_prefix = "â±ï¸ " if use_emoji else ""
            safe_print(f"  {progress_prefix}è¿›åº¦: {position_str}/{duration_str}")

    async def _monitoring_loop(self, interval: int, silent_mode: bool = False):
        """ç›‘æ§å¾ªç¯çš„æ ¸å¿ƒå®ç°"""
        last_song_info = None
        session_start = datetime.now()
        tracks_in_session = 0
        
        try:
            while self.running and not self._stop_flag:
                try:
                    media_info = await self.get_media_info()
                    
                    # æ£€æŸ¥åœæ­¢æ ‡å¿—
                    if self._stop_flag:
                        break
                    
                    if media_info and media_info.get('title'):
                        current_song_id = f"{media_info.get('title')}_{media_info.get('artist')}_{media_info.get('app_name')}"
                        last_song_id = f"{last_song_info.get('title', '')}_{last_song_info.get('artist', '')}_{last_song_info.get('app_name', '')}" if last_song_info else ""
                        
                        # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°æ­Œæ›²æˆ–çŠ¶æ€å˜ä¸ºæ’­æ”¾
                        if (current_song_id != last_song_id and media_info.get('status') == 'Playing') or \
                           (last_song_info and last_song_info.get('status') != 'Playing' and media_info.get('status') == 'Playing'):
                            
                            current_time = datetime.now()
                            self._format_media_output(media_info, current_time, silent_mode)
                            
                            # ä¿å­˜åˆ°æ•°æ®åº“
                            if db.save_media_info(media_info):
                                if not silent_mode:
                                    save_prefix = "âœ… " if config.should_use_emoji() else ""
                                    safe_print(f"  {save_prefix}å·²ä¿å­˜åˆ°æ•°æ®åº“")
                                tracks_in_session += 1
                            else:
                                if not silent_mode:
                                    skip_prefix = "â„¹ï¸ " if config.should_use_emoji() else ""
                                    safe_print(f"  {skip_prefix}é‡å¤è®°å½•ï¼Œè·³è¿‡ä¿å­˜")
                                
                            if not silent_mode:
                                safe_print("-" * 60)
                            last_song_info = media_info.copy()
                    
                    # æ£€æŸ¥åœæ­¢æ ‡å¿—å†æ¬¡ï¼Œé¿å…ä¸å¿…è¦çš„ç­‰å¾…
                    if self._stop_flag:
                        break
                        
                    # ä½¿ç”¨å¯ä¸­æ–­çš„sleep
                    try:
                        await asyncio.sleep(interval)
                    except asyncio.CancelledError:
                        logger.debug("ç›‘æ§å¾ªç¯ä¸­çš„sleepè¢«å–æ¶ˆ")
                        break
                        
                except asyncio.CancelledError:
                    logger.debug("ç›‘æ§å¾ªç¯è¢«å–æ¶ˆ")
                    break
                except Exception as e:
                    logger.error(f"ç›‘æ§å¾ªç¯ä¸­å‘ç”Ÿé”™è¯¯: {e}")
                    if not silent_mode:
                        safe_print(f"ç›‘æ§è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
                    
                    # å¦‚æœå‘ç”Ÿé”™è¯¯ï¼ŒçŸ­æš‚ç­‰å¾…åç»§ç»­
                    if not self._stop_flag:
                        try:
                            await asyncio.sleep(1)
                        except asyncio.CancelledError:
                            break
                
        finally:
            # ä¿å­˜ä¼šè¯ä¿¡æ¯
            if tracks_in_session > 0:
                try:
                    db.save_session_info(session_start, datetime.now(), 
                                       last_song_info.get('app_name', 'Unknown') if last_song_info else 'Unknown', 
                                       tracks_in_session)
                    if not silent_mode:
                        safe_print(f"æœ¬æ¬¡ä¼šè¯æ’­æ”¾äº† {tracks_in_session} é¦–æ­Œæ›²")
                except Exception as e:
                    logger.error(f"ä¿å­˜ä¼šè¯ä¿¡æ¯æ—¶å‡ºé”™: {e}")

    async def monitor_media(self, interval: int = None, silent_mode: bool = False) -> None:
        """ç›‘æ§åª’ä½“æ’­æ”¾å¹¶è®°å½•"""
        if interval is None:
            interval = config.get_monitoring_interval()
            
        if not silent_mode:
            safe_print("å¼€å§‹ç›‘æ§åª’ä½“æ’­æ”¾...")
            safe_print("æ”¯æŒæ‰€æœ‰å…¼å®¹ Windows Media Transport Controls çš„åº”ç”¨")
            safe_print("æŒ‰ Ctrl+C åœæ­¢ç›‘æ§\n")
        
        self.running = True
        self._stop_flag = False
        logger.info(f"å¼€å§‹åª’ä½“ç›‘æ§ï¼Œé—´éš”: {interval}ç§’ï¼Œé™é»˜æ¨¡å¼: {silent_mode}")
        
        try:
            # åˆ›å»ºç›‘æ§ä»»åŠ¡
            self._monitoring_task = asyncio.create_task(self._monitoring_loop(interval, silent_mode))
            await self._monitoring_task
            
        except KeyboardInterrupt:
            if not silent_mode:
                safe_print(f"\næ¥æ”¶åˆ°é”®ç›˜ä¸­æ–­ä¿¡å·")
        except asyncio.CancelledError:
            if not silent_mode:
                safe_print(f"\nç›‘æ§ä»»åŠ¡è¢«å–æ¶ˆ")
        except Exception as e:
            logger.error(f"ç›‘æ§è¿‡ç¨‹ä¸­å‘ç”Ÿæœªé¢„æœŸçš„é”™è¯¯: {e}")
            if not silent_mode:
                safe_print(f"\nç›‘æ§è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        finally:
            # æ¸…ç†å·¥ä½œ
            self.running = False
            self._stop_flag = True
            
            if not silent_mode:
                safe_print(f"\nç›‘æ§å·²åœæ­¢")
            
            logger.info("åª’ä½“ç›‘æ§å·²åœæ­¢")

# å…¨å±€ç›‘æ§å™¨å®ä¾‹
monitor = MediaMonitor()
```

3. **`interface/app_launcher.py`** - äº†è§£åº”ç”¨çš„å¯åŠ¨å’Œå‘½ä»¤å¤„ç†æœºåˆ¶

```python
class AppLauncher:
    def __init__(self):
        self.args = None
        self.verbose = False
    
    def debug_print(self, message):
        """åªåœ¨ verbose æ¨¡å¼ä¸‹æ‰“å°è°ƒè¯•ä¿¡æ¯"""
        if self.verbose:
            safe_print(message)
    
    def setup_environment(self):
        """ç¯å¢ƒåˆå§‹åŒ–å’Œé…ç½®è®¾ç½®"""
        # è§£æå‘½ä»¤è¡Œå‚æ•°
        self.args = parse_arguments()
        self.verbose = getattr(self.args, 'verbose', False)
        
        # è®¾ç½®æ‰€æœ‰æ¨¡å—çš„ verbose æ¨¡å¼
        from utils.system_utils import set_verbose_mode as set_system_verbose
        from config.config_manager import set_verbose_mode as set_config_verbose
        set_system_verbose(self.verbose)
        set_config_verbose(self.verbose)
        
        # è®¾ç½®å·¥ä½œç›®å½•
        self._setup_working_directory()
        
        # è®¾ç½®æ˜¾ç¤ºå’Œæ—¥å¿—é€‰é¡¹
        self._setup_display_and_logging()
    
    def _setup_working_directory(self):
        """è®¾ç½®æ­£ç¡®çš„å·¥ä½œç›®å½•"""
        if getattr(sys, 'frozen', False):
            # æ‰“åŒ…åçš„exeï¼Œåˆ‡æ¢åˆ°exeæ‰€åœ¨ç›®å½•
            exe_dir = Path(sys.executable).parent
            os.chdir(exe_dir)
            self.debug_print(f"ğŸ”§ è°ƒè¯•ï¼šå·²åˆ‡æ¢å·¥ä½œç›®å½•åˆ°: {exe_dir}")
        else:
            # å¼€å‘æ¨¡å¼ï¼Œåˆ‡æ¢åˆ°è„šæœ¬æ‰€åœ¨ç›®å½•
            script_dir = Path(__file__).parent.parent  # å›åˆ°é¡¹ç›®æ ¹ç›®å½•
            os.chdir(script_dir)
            self.debug_print(f"ğŸ”§ è°ƒè¯•ï¼šå·²åˆ‡æ¢å·¥ä½œç›®å½•åˆ°: {script_dir}")
        
        self.debug_print(f"ğŸ”§ è°ƒè¯•ï¼šå½“å‰å·¥ä½œç›®å½•: {os.getcwd()}")
    
    def _setup_display_and_logging(self):
        """è®¾ç½®æ˜¾ç¤ºé€‰é¡¹å’Œæ—¥å¿—çº§åˆ«"""
        # è®¾ç½®æ˜¾ç¤ºé€‰é¡¹
        if hasattr(self.args, 'no_emoji') and self.args.no_emoji:
            config.set("display.use_emoji", False)
        
        # è®¾ç½®æ—¥å¿—çº§åˆ«
        if self.verbose:
            config.set("logging.level", "DEBUG")
        elif hasattr(self.args, 'quiet') and self.args.quiet:
            config.set("logging.level", "WARNING")
    
    def _setup_environment_for_daemon(self):
        """ä¸ºå®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼è®¾ç½®ç®€åŒ–çš„ç¯å¢ƒ"""
        # è®¾ç½®å·¥ä½œç›®å½•
        self._setup_working_directory()
        
        # è®¾ç½®verboseæ¨¡å¼åˆ°å„ä¸ªæ¨¡å—
        from utils.system_utils import set_verbose_mode as set_system_verbose
        from config.config_manager import set_verbose_mode as set_config_verbose
        set_system_verbose(self.verbose)
        set_config_verbose(self.verbose)
        
        # è®¾ç½®æ—¥å¿—çº§åˆ«
        if self.verbose:
            config.set("logging.level", "DEBUG")
    
    def is_daemon_worker_mode(self):
        """æ£€æŸ¥æ˜¯å¦æ˜¯å®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼"""
        return os.environ.get('MEDIA_TRACKER_DAEMON_WORKER') == '1'
    
    def handle_daemon_worker_mode(self):
        """å¤„ç†å®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼"""
        # å…ˆè§£æå‚æ•°ä»¥è·å– verbose è®¾ç½®
        self.args = parse_arguments()
        self.verbose = getattr(self.args, 'verbose', False)
        
        # è®¾ç½®ç¯å¢ƒï¼ˆå¤ç”¨ç°æœ‰é€»è¾‘ï¼‰
        self._setup_environment_for_daemon()
        
        # è·å–è¿è¡Œå‚æ•°
        interval = getattr(self.args, 'interval', None) or config.get_monitoring_interval()
        pid_file_path = os.environ.get('MEDIA_TRACKER_PID_FILE')
        
        if not pid_file_path:
            safe_print("âŒ å®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼ï¼šç¼ºå°‘PIDæ–‡ä»¶è·¯å¾„")
            logger.error("å®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼ï¼šç¼ºå°‘PIDæ–‡ä»¶è·¯å¾„")
            sys.exit(1)
        
        # åˆ›å»ºå¹¶è¿è¡Œå®ˆæŠ¤è¿›ç¨‹å·¥ä½œæ¨¡å¼
        daemon_mode = DaemonMode(monitor)
        daemon_mode.set_verbose(self.verbose)
        daemon_mode.run_daemon_worker(interval, pid_file_path)
    
    def handle_commands(self):
        """å¤„ç†å„ç§å‘½ä»¤ï¼Œè¿”å›Trueè¡¨ç¤ºå‘½ä»¤å·²å¤„ç†å¹¶åº”è¯¥é€€å‡º"""
        # å¤„ç†åœæ­¢å‘½ä»¤
        if self.args.stop:
            ProcessManager.stop_background_process(self.args.pid_file)
            return True
        
        # æ£€æŸ¥ä¾èµ–ï¼ˆå¯¹äºéœ€è¦monitorçš„å‘½ä»¤ï¼‰
        if not check_and_install_dependencies():
            return True
        
        # æ˜¾ç¤ºæœ€è¿‘æ’­æ”¾
        if self.args.recent is not None:
            display.show_recent_tracks(self.args.recent)
            return True
        
        # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
        if self.args.stats:
            display.show_statistics()
            return True
        
        # å¯¼å‡ºå†å²è®°å½•
        if self.args.export:
            ExportManager.export_to_file(self.args.export)
            return True
        
        return False
    
    def launch_mode(self):
        """å¯åŠ¨å¯¹åº”çš„è¿è¡Œæ¨¡å¼"""
        # å®ˆæŠ¤è¿›ç¨‹æ¨¡å¼
        if self.args.daemon:
            daemon_mode = DaemonMode(monitor)
            daemon_mode.set_verbose(self.verbose)
            setup_signal_handlers(monitor)
            daemon_mode.run_daemon(self.args.interval, self.args.pid_file)
            return
        
        # åå°ç›‘æ§æ¨¡å¼
        if self.args.background:
            background_mode = BackgroundMode(monitor)
            setup_signal_handlers(monitor)
            try:
                import asyncio
                asyncio.run(background_mode.run(self.args.interval, self.args.quiet))
            except KeyboardInterrupt:
                safe_print("\nåå°ç›‘æ§å·²åœæ­¢")
            return
        
        # é»˜è®¤äº¤äº’æ¨¡å¼
        interactive = InteractiveMode(monitor)
        interactive.run()
    
    def handle_error(self, error):
        """ç»Ÿä¸€é”™è¯¯å¤„ç†"""
        safe_print(f"âŒ åº”ç”¨å¯åŠ¨å¼‚å¸¸: {error}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

```

## åŒæ—¶è¯·å‘Šè¯‰æˆ‘

1. **å½“å‰é¡¹ç›®çš„ä¸»è¦åŠŸèƒ½æ˜¯ä»€ä¹ˆï¼Ÿ**
   - é€šè¿‡SMTCè·å–å¹¶è®°å½•æ’­æ”¾è¿‡çš„åª’ä½“ä¿¡æ¯

2. **æ‚¨å¸Œæœ›å¦‚ä½•è§¦å‘QQéŸ³ä¹æ­Œå•åˆ é™¤åŠŸèƒ½ï¼Ÿ**
   - åœ¨äº¤äº’æ¨¡å¼ä¸­æ·»åŠ é€‰é¡¹
   - å¹¶ä¸”ä½œä¸ºç‹¬ç«‹çš„åŠŸèƒ½æ¨¡å—
   - å¯ä»¥åœ¨å¦ä¸€ä¸ªæ¨¡å—ï¼ˆä¾‹å¦‚å®šæ—¶æ¨¡å—ï¼ˆå°šæœªå®ç°ï¼‰ï¼‰ä¸­è°ƒç”¨

3. **éœ€è¦åˆ é™¤çš„æ­Œæ›²ä¿¡æ¯ä»å“ªé‡Œæ¥ï¼Ÿ**
   - ä»æ•°æ®åº“ä¸­çš„æ’­æ”¾è®°å½•

4. **æ˜¯å¦éœ€è¦åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ QQéŸ³ä¹ç›¸å…³çš„é…ç½®é¡¹ï¼Ÿ**ï¼ˆæ¯”å¦‚æ­Œå•åç§°ã€åˆ é™¤è§„åˆ™ç­‰ï¼‰
   - éœ€è¦æ·»åŠ 